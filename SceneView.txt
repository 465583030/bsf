
 GIZMO TODO:
  - Figure out how to deal with builtin components like Camera and Renderable (e.g. how will they have gizmos since they're not managed components?)
    - Make those two a non-component types. Anywhere they are used in the Renderer they should just be passed as pointers.
	- Then make a Component wrapper around the non-component types, and also a C# wrapper around the same types

TESTING:
 - Depth rendering in scene view on OpenGL is all screwed up
 - Test picking on an object with alpha
 - Ensure that selecting an item in scene properly marks it in scene view
 - Ensure that selecting an item in scene or resource tree view properly updates Selection

Test gizmos
 - Test rendering of icon gizmos
 - HOOK UP GIZMO SELECTION and test it

Test handles
 - Handle rendering might require similar refactor to GizmoManager
 - Test basic move handle
 - Test a custom handle from C#
 - FINISH HANDLE IMPLEMENTATION AND GLUE EVERYTHING TOGHETHER

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK
 - LIKELY USE PIXEL SceneGrid WITH AA

Need a way to drag and drop items from Scene tree view to Scene view

LATER:
 - Need a way to render text for gizmos and handles, and in scene in general
 - Add drag to select
 - Need a better system to catch broken shaders. DX11 just draws nothing with depth, DX9 draws all white.

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

ScriptHandleManager
 - Needs to be started up somewhere

SceneEditorWidget
 - Need to glue everything together

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

----------------------------------------------------------------------
SceneView editor flow:
  Hook up gizmo, handle and selection rendering methods to be executed after the scene is rendered
  Calculate mouse coords manually relative to the window and to the render texture GUI element
     - Don't use GUI events as we require more precise control (do we?)

  Detect mouse clicks on the scene render target
      Forward those mouse coordinates to HandleManager
      It checks if screen ray intersects any handles and returns the handle if it does
         If handle is found it is activated and method returns
         Otherwise we mark the coordinates as selection start

  Detect mouse drag on the scene render target
    - If we have an active handle
         Forward mouse coordinates to the active handle so it can do its thing
         return
    - Otherwise its assumed we are dragging a selection
         Update selection endpoint and send it to ScenePicking
         Use Selection to select picked objects if any
         return

  Detect mouse release on scene render target
     If we have an active handle
        Clear active handle
        return
     Otheriwse its assumed we are dragging a selection
        Do nothing
        return

---------------------------------------------------------------------
Multi-resources

 Importer::import
  - Each SpecificImporter is responsible for importing all needed resources and registering them with Resources manager
  - However only the main resource is returned from that method
  - Rest of the resources are referenced by the UUID in ResourceMeta and can be retrieved there if needed

 Resources::save
  - Add to documentation that it will only save that exact resource and not any dependencies, you must call save() for them manually

 Resources::load
  - Will automatically load all dependencies, optionally add a boolean that allows you to load only the main asset

ProjectLibrary
 - Needs to be extended so it shows sub-resources in tree view
 - Need to extend my mapping so one asset maps to multiple assets in library (need to remember how I do that currently, is it just by name or meta-file identifier?)

---------------------

With this approach I can:
 - Reference and load the sub-resources directly
 - Technically I can also delete sub-resources