
TODO:
 - Core thread gets stuck on shutdown when OpenGL is used...Somewhere in kernel

Weekend:
 - Set up grid material and hook it up to renderer (+ actually instantiate it in EditorApplication)

TODO - Think about:
 - How will I allow user from C# to draw gizmos and handles?
 - Unity uses immediate mode
 - I should probably focus more on implementing a nice C# drawing interface so I don't constantly have to go and use C++
    - Although this might be overkill for this point - I think even Unitys handles/gizmos are C++ in the end

----------------------------------------------------------------------
Handles

 - Make a few different base handle types:
   - Slider 1D (e.g. for movement using an arrow cap)
   - Slider 2D (e.g. for movement in 2D using a plane render)
   - Similar for scale/rotation handles  (see Unity for its implementations of those)

Handles should have colliders which will be queries whenever user input is detected in scene view
If any handle is hit the input will not proceed further (e.g. no picking will be done) and that handle control
will become active.

Base handle types should just be positioned in space and then return value every frame as user moves them.
 - This way they can also easily be used from C# for custom user-made stuff

TODO - Think about this
See for inspiration: http://docs.unity3d.com/ScriptReference/Handles.html

----------------------------------------------------------------------
Picking

BsPicking
 - HGameObject PickClosestGameObject(Camera cam, Vector2 position, Vector2 area)
 - PickResult PickClosestObject(Camera cam, Vector2 position, Vector2 area)
 - void PickGameObjects(Camera cam, Vector2 position, Vector2 area, Vector<HGameObject>& selection)
 - void PickObjects(Camera cam, Vector2 position, Vector2 area, Vector<PickResults>& selection)

PickResult
 Type (GameObject or Gizmo)
 Data (Handle to GameObject or gizmo ID)

Picking will internally:
 - Be performed on the Scene render target just before actual rendering
 - Use scissor rect to limit itself to the specified screen area
    - TODO later - I could also limit the camera frustum to this area for additional culling

 - Go through every scene object and find all renderables
 - Perform culling over all renderables and generate a list of visible nodes
 - Access GizmoManager and get a list of all gizmos and their IDs
 - Generate unique colors for all renderables and gizmos
 - Send meshes/colors/ids to core thread to be rendered with a special shader
 - Wait until core thread completes and returns an AsyncOp with a list of selected IDs

 - Ensure I can read-back from a render target on the core thread
  - Check DX9, DX11 and OpenGL implementations for both render textures and render windows

Also:
 - I need to send the primary used texture so I properly determine transparent areas using alpha
   - TODO - But I do not have a way of defining a primary texture in-engine. Add a renderer semantic?

----------------------------------------------------------------------
Rendering selection

Get the mesh from the selected Renderable
Draw that same mesh again using a shader that grays out the original
The second mesh will likely need to use depth bias (sloped depth bias too?)

----------------------------------------------------------------------
Grid

Generate grid of X size around Y point
Normally Y is (0, 0, 0) but we should be able to move it with camera
There will be minor and major axes with slightly different color (and thickness?)
Instead of pixel perfect lines draw 2D quads (Using DrawHelper which has thick line support)

Mesh can be static, I can just move its origin by length of the major line (+ maybe have a fadeout in shader with 1 invisible major line so the movement is not noticeable)
Material is retrieved from builtin materials list

This can be drawn directly using the draw list and not a renderable

----------------------------------------------------------------------
Gizmos

Custom gizmos:
 - Users can override the Gizmo class to create their own custom gizmos
 - It contains various methods that can be used for constructing the gizmo
   - DrawCube
   - DrawSphere
   - DrawWireCube
   - DrawWireSphere
   - DrawRay
   - DrawLine
   - DrawFrustum
   - DrawIcon

 - Any Gizmo is registered with GizmoTypes manager
 
 - Components may associate themselves with a gizmo using [SetGizmo(Gizmo)] attribute
  - It contains other properties, like when should gizmo be displayed (active, selected, not selected, parent selected) and whether
    or not the gizmo is pickable

 - When drawing an icon
   - It should always face the camera
   - It can be static size in screen space, or resizable with distance

 - Need a way to notify the gizmo needs updating from component with the gizmo
   - Gizmos.MarkDirty(GameObject)

 - How do I assign a texture to DrawIcon? I'm assuming Gizmo class will not have an inspector.
   - A special ManagedResource that allows you to assign textures to it?
     - WIll need a Dictionary inspector?

Gizmo rendering:
GizmoTypes
 - All gizmo types are registered here
 - It contains prebuilt gizmo meshes and textures

GizmoManager
 - Every frame goes through all game objects and create/removes their gizmos. It keeps a cached version of all gizmos
 - It keeps a list of gizmo descriptors
 - A "diff" of this list is sent to Core thread every frame

GizmosRenderer
 - Batches all gizmos into a single buffer and renders them with a single call
 - It might be a bit problematic if custom textures are used for gizmos
    - Just don't batch those? Yep, probably not worth batching at this point.

When picking GizmosRenderer can draw the gizmos as normal but using a special shader.
