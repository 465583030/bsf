
 GIZMO TODO:
  - Make a C# wrapper for Camera and Renderable

REFACTOR material getParams* and related classes. Those params should update all gpu program params that share that variable, not just the first found
Need a way to drag and drop items from Scene tree view to Scene view
When dragging a handle make sure it works when cursor leaves the scene view
Also make sure that handle manager receives mouse up event if its done outside of scene view
When selecting/deselecting stuff handle display is delayed

Create the scene widget completely in C#?
 - Port Camera/viewport, RenderTexture, SceneCameraController, Input, ProjectSettings, SceneGrid
 - Will need to track when widget resizes so I can resize the render target
 - Handle manager update will originate from the widget
  - Actually it could still be done from C++
 - How will scene grid rendering be handled? Currently it's done from a render() callback
  - It's still going to have a C++ representation, just call the callback there
 - I will still need a C++ version of scene widget (not in script code but in editor code) because handle/gizmo manager reference it
 
AFTER I have scene widget in C#:
 - Finish up C# Handles class so it returns proper values
 - Ensure fixed handle size and handle snapping works
 - Implement free move handle and remaining handles
 - Test custom handles from C#


IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK
 - LIKELY USE PIXEL SceneGrid WITH AA
 - OR (better) instead of drawing rows and columns of lines, just draw a plane with procedural texture

LATER:
 - Need a way to render text for gizmos and handles, and in scene in general
 - Add drag to select
 - Need a better system to catch broken shaders. DX11 just draws nothing with depth, DX9 draws all white.

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------
Render textures in C#:
 - Extend C++ code so I can render to a 2D texture, face of a cube map, slice of a volume texture or entry in a 2D texture array.
 - In C# have Texture2D, TextureCube, TextureVolume, Texture2DArray. They should have a common Texture base.
   - Each of those can be created with a Renderable flag
 - Render textures mirror what we have in C++
   - RenderTexture and MultiRenderTexture (since we have these separate representation we don't need RenderBuffer that Unity has)
   - You can provide an existing texture from types listed above, or create a new render target and
      create a basic 2D texture (multiple constructors)
 - Both RT types should have their color buffer (s) and depth buffer accessible as a texture to be used for rendering, or for reading

---------------------------------------------------------------------
Multi-resources

 Importer::import
  - Each SpecificImporter is responsible for importing all needed resources and registering them with Resources manager
  - However only the main resource is returned from that method
  - Rest of the resources are referenced by the UUID in ResourceMeta and can be retrieved there if needed

 Resources::save
  - Add to documentation that it will only save that exact resource and not any dependencies, you must call save() for them manually

 Resources::load
  - Will automatically load all dependencies, optionally add a boolean that allows you to load only the main asset

ProjectLibrary
 - Needs to be extended so it shows sub-resources in tree view
 - Need to extend my mapping so one asset maps to multiple assets in library (need to remember how I do that currently, is it just by name or meta-file identifier?)

---------------------

With this approach I can:
 - Reference and load the sub-resources directly
 - Technically I can also delete sub-resources