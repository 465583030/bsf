Classes that need C# wrappers:
Resources:
 - Mesh
 - Texture
 - Font
 - Material
  - GpuProgram
  - Technique
  - Shader
  - DepthStencil/Blend/Rasterizer/Sampler state

Core objects:
 - SceneObject
 - Component
  - plus specific components Camera, Renderable, maybe others
  - (later ofc ability to derive custom C# components)

GUI:
 - EditorWindow
 - GUIWidget
 - GUILabel/GUIButton/GUIToggle/GUIInputBox/GUITexture...
 - GUILayoutX/GUILayoutY/GUILayoutOptions
 - GUISkin/GUIElementStyle

Systems:
 - Resources
 - Importer
 - Application (startUp/shutDown)
 - Cursor
 - Debug
 - Input
 - Time

 -----------------

 Implementation steps:
  - Implement flexible TreeView GUI component
  - Finish up Window Docking
  - EditorApplication
   - a way to return currently open project
  - Rethink how Resource .metas are handled
  - Implement Resource window
    - C# Importer (Internal class)
     - Imports resources and stores it within Library of the current Project folder
    - C# Resources, Save, Create
    - (Drag and drop import)
    - (File edit tracking)

----------------------------

 - GUISkin
   - List of properties with all common styles, like .button, .label
   - Get/SetStyle methods for custom styles
   - GUISkin.main <- default skin
 - GUI (Non EditorGUI version)

 - Implement C# Font
 - Implement C# SpriteTexture

When loading resources I need to be able to load both project resources and engine ones. 
 - BuiltinResources can be used for accessing default resources like GUI skin textures and similar
 - They're all loaded from a special folder that is set in EditorApplication

 BsApplication::getPrimaryViewport is not implemented

 Ensure I can easily ensure that engine and run separate from editor for when game publishing will be implemented.

 -----------------

 Notes:
  - I will need RequireComponent[] attribute. This attribute should automatically add the specified class to the wanted
    GameObject. This is useful if you suddenly decide your class is now dependant on another, but you would otherwise have to manually
	go through all instances of that GameObject in scene and add the required component.
	  - HOWEVER, a more generic way of doing this (maybe using prefabs) would be useful. Because what happens when a class suddenly becomes
	    dependant on a resource, or a specific instance of a class? In that case we cannot use RequireComponent.
  - Use FrameUpdate[QueueIdx], OnCreate[QueueIdx], OnDestroy[QueueIdx] attributes to signify to the scripting system when to execute
    certain methods. QueueIdx allows you to specify the order in which these methods will be called. In Unity you have Awake and Start methods
	for initialization, but here you may just specify OnCreate[0] and OnCreate[1].
	  - I will likely need C++ equivalents of these queues because C++ components will also require such ordering. 