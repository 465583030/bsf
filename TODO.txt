--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

See GDrive/Resources doc for resources refactor

TODO - Material waits to Shader to be loaded but doesn't wait for shader GpuPrograms. 
 - What's the best way to ensure initialization is done when all these are loaded?

Make RenderTexture accept a HTexture

ManagedComponent deserialization IS WRONG
 - I register the component with ScriptGameObjectManager during deserialization when its ID is wrong

Add a special mode to GameObjectManager that is active during deserialization
 - Any handle or GameObject deserialized when its active will use a special mapping for resolving/updating IDs
  - THIS doesn't really work because I might need to resolve a handle before the object is deserialized
  - But could I add entries to the map from both handle and object regardless of which is resolved first?
    - YES - This gets rid of the need for post-processing of GameObject, solves my ScriptComponent deserialization issue and allows me to deserialize managed fields on demand

Modify managed serialization so that deserialization/serialization happens per field instead of in deserialize/serialize methods during pre- and post-processing step.
 - Make sure to fix the GameObjectManager delayed deserialization issue first
 - When generating SerializableFieldInfo generate mFieldGlobalIdx (index that takes into consideration any base classes)
   - Then when de/serializing use that index to get field info and call get/setFieldData accordingly in RTTI getter/setter directly
   - How to use it when deserializing though?
     - Ensure that ManagedObjectInfo is deserialized first. Since this is an unclear dependency make sure to add asserts so when it fails it is clear why.
     - Then use that to look up field during runtime

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Other:
Window resize end callback
Add cutoff plane when rendering discs for rotation handle.
What happens when I close widgets from C++ code (e.g. due to layout reload or change)? Will C# still try to access them?

C# SceneView:
Test new Scene window and fix every issue
Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

-----------------

Need a way to drag and drop items from Scene tree view to Scene view

AFTER I have scene widget in C#:
 - Implement free move handle and remaining handles
 - Test custom handles from C#
 - Test handle snapping

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK - Use the shader created in Unity

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add 2D move and scale
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------