--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

<<<<<Assembly refresh>>>>>

When serializing Camera I cannot save the reference to RenderTexture. Make it a Resource?
Possibly set up automatic refresh in debug mode after initialization? As an ad-hoc unit test

<<<<<Simple stuff>>>>>>

Test file/folder open/save dialog

Add a simple way to create modal dialogs (ModalDialog in C#, similar to EditorWindow)
Modal window needs a title bar probably (with an X button, which would be optional)
 - When I add it make sure to update GUIPanel area in ScriptModalWindow

C#:
Dialog.Show(title, text, btn1 text, btn1 callback, btn2 text, btn2 callback, btn3 text, btn3 callback)
ProgressBar.Show(float percent) / ProgressBar.Hide()


Add C# wrappers GUIElement bounds and visible bounds (with ability to set non-visible bounds)

Got a crash on shutdown that was caused by locking a mutex in an Event destructor. Event was Platform::onMouseCaptureChanged. 
Issue happened when I closed the app via the X button (if that's relevant). It doesn't seem to happen always.

<<<<<<Handles>>>>>>>>

When scaling using center make sure to offset the object before scale
Handles should probably not having shading, or have better shading.

Rotate handle:
 - How to handle local/global with rotate handle?
   - This maybe just determines initial rotation of the handle?
   - I don't think my code properly handles rotation handle transforms (e.g. arc drawing)

Ideally free scale handle indicator should always render and be interactable and never be hidden by axis scale indicators (Not high priority)

<<<<Multi-resource saving>>>>:
 - Modify Font so it doesn't contain a texture, but instead keeps a handle to it
 - Register it in its meta file
 - When saving such a resource with dependencies save the contained files to a sub-directory with the same name as top level resource
   - If it already exists in the manifest at a different location do it anyway, keep the other copy as-is in case user wanted it that way
   - I'm not sure whether to do this for all Resource::save calls or only ones originating from ProjectLIbrary?

Other:
Window resize end callback

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Running embedded mono with VS attached causes managed null refs to be registered as access violations

There seems to be a bug in Mono when passing complex structs from C# to C++. e.g. passing Rect3 as a parameter
will corrupt the parameter after it, even if layout and size is exact as the C++ version. 
Rect3 has child structs (Vector3) which could be the reason. Be aware of other similar problems.

Create a stack allocatable custom vector implementation and make getResourceDependencies and getCoreDependencies use it.
 - These methods are called often and cause allocations whenever they are.

C# SceneView:
Test new Scene window and fix every issue
Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

Need a way to drag and drop items from Scene tree view to Scene view
 - When dragging a mesh it should by default create a SceneObject with a renderable
 - I might want a C# DragAndDrop class? It can contain Resource or SceneObject only for now, similar to Selection

AFTER I have scene widget in C#:
 - Test custom handles from C#
 - Test handle snapping

IMPROVE SceneGrid LOOK - Use the shader created in Unity

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias