--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

See GDrive/Resources doc for resources refactor

There seems to be some kind of memory corruption that happens when cloning game objects. During one clone the field entries provided to
ManagedSerializeArray::deserializeManagedInstance were reported as ManagedSerializedArray instead of ManagerSerializedFieldData types.
It's inconsistent to reproduce but started happening after I have modified managed object serialization to be on-demand. It's possibly
related to lambdas not capturing types as I expect them to. It always happens in the same place.

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Multi-resource saving:
 - Modify Font so it doesn't contain a texture, but instead keeps a handle to it
 - Register it in its meta file
 - When saving such a resource with dependencies save the contained files to a sub-directory with the same name as top level resource
   - If it already exists in the manifest at a different location do it anyway, keep the other copy as-is in case user wanted it that way
   - I'm not sure whether to do this for all Resource::save calls or only ones originating from ProjectLIbrary?

Other:
Window resize end callback
Add cutoff plane when rendering discs for rotation handle.
What happens when I close widgets from C++ code (e.g. due to layout reload or change)? Will C# still try to access them?

C# SceneView:
Test new Scene window and fix every issue
Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

-----------------
Resource refresh:
 - Add ScriptObject::beginRefresh, ScriptObject::endRefresh
   - Each ScriptObject can internally store data needed for refresh (e.g. serialized instance and similar)
   - beginRefresh needs to at least clear mCachedPtr (and ensure when managed objects get destroyed that ScriptObjects stay as is)
   - endRefresh needs to at least restore mCachedPtr
   - Depending on ScriptObject other functionality might be needed
 - After refresh check if type still exists, and if it doesn't delete the ScriptObject (or throw an assert if that wasn't supposed to happen)
 - Add MonoManager::refreshDomain. This releases current domain (and all assemblies in it), and allocates a new one
 - Add CoreApplication::refreshManagedAssemblies
    - Calls ScriptObject::beginRefresh, MonoManager::refreshDomain and ScriptObject::endRefresh
    - Will also need to call RuntimeScriptManager and some other types that rely on Mono types

When restoring manage instance don't call the constructor. Currently some constructors call native methods that set up ScriptObjects, which is not what I want to do.
 - Unity does call the constructor so if it turns out to be necesary go on a case by case basis and change their constructors so they do not call into native code. (Or if they have to, to check if the object isn't already initialized)

Find all references to: MonoObject, MonoClass, MonoField, MonoProperty, MonoMethod, MonoAssembly, function thunks and ensure those are properly released and re-constructed during refresh.
 - Make a list and figure out possible issues. Then modify them before starting the refactor.

Find all C# versions of ScriptObject and see if they store any data. If they do that data might need to be serialized and deserialized during refresh.
 - Make a list and figure out possible issues.

Types that I need to ensure stay valid after refresh:
 - Any Component, Resource and GUI object
 - EditorWindow

Types I can probably ignore:
 - SerializableProperty and related types
   - They can't be serialized by anything. So technically after refresh we're forced to create new ones anyway.
 - HandleSlider
   - Also can't be serialized.

I need to ensure to call all start-up methods after refresh.
 - e.g. Component onInitialize and whatever is called for EditorWindow or inspectors

-----------------

Need a way to drag and drop items from Scene tree view to Scene view

AFTER I have scene widget in C#:
 - Implement free move handle and remaining handles
 - Test custom handles from C#
 - Test handle snapping

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK - Use the shader created in Unity

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add 2D move and scale
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------