--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

See GDrive/Resources doc for resources refactor

TODO - Material waits to Shader to be loaded but doesn't wait for shader GpuPrograms. 
 - What's the best way to ensure initialization is done when all these are loaded?

Make RenderTexture accept a HTexture

When resource loading starts synchonously read all dependencies (and recurse over their dependencies too)
 - Create a ResourceLoadGroup that contains all the non-loaded resources
 - Cue async loads for all resources
 - Perform sync loads for resources that don't support async
 - return an unloaded handle

Each time an async load completes check if the resource is part of a resource load group
 - If all resources in the load group are done (or there was just one resource), resolve all of their handles at once
   and trigger resource listener events.

TODO
 - Pay special care in case a resource in resource load group gets unloaded. I should ignore it to avoid a deadlock that never finishes the resource load.
 - Allow for a situation if resource is part of multiple load groups.

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Other:
Window resize end callback
Add cutoff plane when rendering discs for rotation handle.
What happens when I close widgets from C++ code (e.g. due to layout reload or change)? Will C# still try to access them?

C# SceneView:
Test new Scene window and fix every issue
Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

-----------------

Need a way to drag and drop items from Scene tree view to Scene view

AFTER I have scene widget in C#:
 - Implement free move handle and remaining handles
 - Test custom handles from C#
 - Test handle snapping

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK - Use the shader created in Unity

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add 2D move and scale
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------