--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

----------------------------------------------------------------------
Assembly refresh

When serializing Camera I cannot save the reference to RenderTexture. Make it a Resource?
Possibly set up automatic refresh in debug mode after initialization? As an ad-hoc unit test

Modal windows are set up as persistent but I don't serialize their internal data anywhere

----------------------------------------------------------------------
C# Material/Shader:

TODO - Implement param block and sampler support
TODO - When creating a Material without a shader, a default one should be used, at least in editor
TODO - Setting Material array parameters isn't possible from C#

GUIResourceField doesn't distinguish between tex2d, tex3d and texcube.

---------------------------------------------------------------------
ProjectLibrary import

I'm not sure if queued dependencies are handled properly. They're handled on an internal ProjectLibrary loop but perhaps I should
return them in checkForModifications?

---------------------------------------------------------------------
Prefab diff

Add "dirty object" system to C#. Each ScriptResource and ScriptGameObject should have a dirty flag.
 - It should be toggle-able via EditorUtility.SetDirty or similar. (Possibly make this part of ProjectLibrary)
 - There should also be a method to check if something is dirty via EditorUtility.IsDirty or similar. (Possibly make this part of ProjectLibrary)
  - Hook this up to Scene.IsModified because it is currently not implemented (Might need to keep a link to active Prefab in scene to do this)
 - Add a "Save Project" button that automatically saves all dirty assets. Do this automatically when user quits the editor.
 - Call SetDirty manually whenever:
  - A new object or component is added to the scene
  - An object or component is removed from the scene
  - An object is reparented
  - When component or resource is modified from inspector
 - Record all portions where objects & components get modified so I can mark them dirty, will likely need
    to use those some points for undo/redo

TODO - Later - When building level for release make sure to clear all prefab diffs (possibly store them elsewhere in the first place)
       - And all prefab instances should have updateFromPrefab called on them.

 Test (likely later once I have more editor functionality working):
  - If level save/load works
  - If drag and drop works, both ways, plus double-click to load level
  - Game object handle compare
  - ID restore systems 
  - Native+Managed diff (only the link between the two)

Code quality improvements:
 - Modify BinarySerializer so that _encodeIntermediate outputs intermediate format directly without a full on encode
 - Consider making ManagedSerializable* array/list/dictionary method/field references static (right now each instance has its own instance
   but they're identical)

----------------------------------------------------------------------
Polish stage 1

UpdateMeshes is taking a long time to rebuild, try to optimize it

Moving the mouse over inspector seems to queue a rebuild for the entire GUIWidget (meaning the whole main window)
 - It seems the parent GUIPanel is marked as dirty
 - Ensure that dirty changes don't propagate outside of EditorWidget
 - Modify GUIElementBase::findUpdateParent
	GUIElementBase* GUIElementBase::findUpdateParent()
	{
		GUIElementBase* currentElement = mParentElement;
		while (currentElement != nullptr)
		{
			const GUIDimensions& parentDimensions = currentElement->_getDimensions();
			bool boundsDependOnChildren = !parentDimensions.fixedHeight() || !parentDimensions.fixedWidth();

			if (!boundsDependOnChildren)
			{
				// If parent is a panel then we can do an optimization and only update
				// one child instead of all of them, so change parent to that child.
				if (currentElement->_getType() == GUIElementBase::Type::Panel)
				{
					GUIElementBase* optimizedUpdateParent = this;
					while (optimizedUpdateParent->_getParent() != currentElement)
						optimizedUpdateParent = optimizedUpdateParent->_getParent();

					currentElement = optimizedUpdateParent;
				}

				return currentElement;
			}

			currentElement = currentElement->mParentElement;
		}

		return nullptr;
	}

ScrollArea doesn't cache its own size range. This means whenever layouts (or other scroll areas) are performing optimal size updates I'm doing 
another whole pass on all of the scroll area's children. While I'm modifying this I should modify how layouts determine whether to retrieve cached 
size range or calculate it (right now I'm testing for exact type, but I need a more generic solution since ScrollArea doesn't qualify as its own type)

Avoid fully recalculating layout for common operations like changing button states/toggles, and modifying input boxes.
 - Layout should be fully recalculated only if:
   - optimal size changes
   - padding changes
   - dimensions change (x/y position only relevant for for panels) (perhaps even only LayoutSizeRange)
   - disabled state changes
   - when initially created
 - I should probably just handle this on a case by case basis (e.g. if changing the active button texture is the same size as previous one don't call contentDirty)


Test scroll areas after optimization pass
Get rid of all the profiling calls

Test inspector selection, selecting a resource and adding/removing component updates
Crash when showing the inspector (invalid index in Layout.InsertElement called from InspectableObject.Update)
Handle seems to lag behind the selected mesh
ProjectLibrary seems to import some files on every start-up
Crash on shutdown in mono_gchandle_free
Material/Shader has no color type so I cannot know when to display normal vector and when color in inspector

First screenshot work:
- Additional menu bar items: 
 - File: Exit, Save Project, New Project, Open Project, Save Scene As
 - Edit: Undo/Redo, Cut/Copy/Paste/Duplicate/Delete(need to make sure it works in Hierarchy, with shortcuts), Frame Selected, Preferences, Play/Pause/Step
 - Assets (also add to context): Create(Folder, Material, Shader, Script, Prefab, GUI Skin), Show in explorer
 - Game Object (also add to context): Create(Empty, Empty Child, Camera, Renderable, Point/Spot/Directional Light), Apply prefab, Break prefab, Revert prefab
   - Possibly create helper objects: Cube, Sphere, Plane, Quad, Capsule, Cylinder
 - Component (also add to inspector context): Camera, Renderable, Point/Spot/Directional light, all other components from scripts
 - Help - About, API Reference (link to site)
- Camera & Renderable inspector
- Normalize colors between project and hierarchy windows (both blue or both orange selection + same ping color)
- (Optionally) New UI look (tabs, component/array containers, better buttons)
- (Optionally) Console window

-----------

SceneTreeView
 - Hook up ping effect so it triggers when I select a resource or sceneobject
   - Add Selection::ping method to both C++ and C# and an Event that triggers when its called
 - See if it needs other enhancements (rename, delete all work properly? etc.)
 - Add copy/cut/paste/duplicate (with context menu)
 - Cannot deselect element by clicking on empty space

Need a way to add scene objects and components (and remove them)
 - Components adding should be only done by drag and dropping scripts to inspector (undoable)
 - COmponent removal should be done by context menu in inspector (undoable)
 - Adding scene objects should be doable from context menu in Hierarchy, by dropping a Prefab or by main Menu (undoable)
 - Deleting them should be doable by context menu in Hierarchy and Del keystroke (undoable)

Add shortcut keys for view/move/rotate/scale
Add "focus on object" key (F) - animate it: rotate camera towards then speed towards while zooming in
Ortographic camera views (+ gizmo in scene view corner that shows camera orientation)
Drag to select in scene view

Replace "minimize" button in tabbed title bar with maximize and make sure it works

Make sure to persist EditorSettings

Later:
 - I could record undo/redo per-property using the new diff system
 - When building game make sure to go over texture resources and ensure they are saved in the valid format
   as we don't want to do format conversion at runtime (Not cruical, but it should be done eventually)
   - This should something similar to Unity where when changing the platform all resources get reimported
 - Save the default editor layout somewhere and make sure its used on initial startup when no layout exists
 - Undo/Redo when breaking or reverting a scene object

----------------------------------------------------------------------
Simple stuff
 - Inject an icon into an .exe (Win32 specific)
 - C# wrapper for GUISkin (and a way to assign the current skin to a window)
 - Move all the code files into subfolders so their hierarchy is similar to VS filters
 - Font doesn't have a C# interface
 - Get rid of PoolAlloc and other unused allocators (plus fix bs_new and others which have weird overloads)
 - Get rid of event callback from HString and figure out a better way
 - Splash screen

----------------------------------------------------------------------
Resources
 - Load/Unload/UnloadUnused
 - Uses same paths as ProjectLibrary
 - It uses different logic depending on Application.isEditor
   - If not in editor then a different path is used
   - That path is ..\..\Data (relative to the executable)
   - When in editor it also does special ProjectLibrary check to ensure that resource is included in final project
 - Internally just calls Resources (C++) Load/Unload/UnloadUnused
 - Need a flag in ProjectLibrary to include a resource in the final build
   - Need to be able to set that flag from C# (Likely through ProjectLibrary) interface
 - The final build procedure for the game would then be:
   - Copy all the prebuilt binaries (Banshee libraries, Banshee assemblies, 3rd party libraries and prebuilt executable) from Editor install folder to output folder
    - Which set of binaries is used depends on selected platform (e.g. win/mac/linux or 32/64bit)
   - Recompile script assemblies if needed and copy them from project Internal folder to output folder
   - Copy the Builtin resources for engine from Editor install folder to output folder
   - Copy all the resources marked with the flag mentioned above to \Data subfolder in the output folder, preserving the same asset structure

----------------------------------------------------------------------
Project window

Later:
 - Might need to improve search (need to test). Do multiple search keywords work properly?
 - Consider delaying search until user stops pressing keys (so not to have thousands of search results in the initial stages)
 - Save & restore scroll position when Refresh happens

----------------------------------------------------------------------
Handles

Ideally free scale handle indicator should always render and be interactable and never be hidden by axis scale indicators (Not high priority)

Later:
 - Raycast snapping Ribek suggested

----------------------------------------------------------------------
Include files:

Test:
 - Test if default values work
 - Test project library dependant resources (e.g. changing an include and seeing if shader is reimported)

----------------------------------------------------------------------
Scene View

Test:
 - Custom handles from C#
 - Handle snapping
 - Multi-select Move/Rotate/scale

----------------------------------------------------------------------
Undo/Redo C#

UndoRedo class
 - RegisterCommand(cmd, operationName)
 - pushGroup
 - popGroup
 - undo
 - redo
 - clear

RecordObjectCommand
 - Saves the entire object and at the end of the frame performs a diff of the object to actually generate the undo operation
 - Must work for scene objects, components and resources
SetParentCommand - For reparenting scene objects
AddComponentCommand
DestroyCommand - for destroying scene objects or components

----------------------------------------------------------------------
Other

There is a memory corruption happening. Haven't determined where exactly but it's possible it has something
to do with the opening of ColorPicker window. One time I got a heap read after delete error caused by GUIManager
attempting to allocate a new transient mesh, and another time I got a hang when inserting a script object into a std::set.

Got a crash on shutdown that was caused by locking a mutex in an Event destructor. Event was Platform::onMouseCaptureChanged. 
Issue happened when I closed the app via the X button (if that's relevant). It doesn't seem to happen always.
 - This is likely due to some other error. When VS finds an exception it triggers a dialog box which triggers the msg loop in-engine and causes another exception.

Create a stack allocatable custom vector implementation and make getResourceDependencies and getCoreDependencies use it.
 - These methods are called often and cause allocations whenever they are.

I shouldn't crash the app when a managed exception happens

/*********************************************************************/
/************************ LESS IMPORTANT *****************************/
/*********************************************************************/

----------------------------------------------------------------------
Mono notes

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Running embedded mono with VS attached causes managed null refs to be registered as access violations

There seems to be a bug in Mono when passing complex structs from C# to C++. e.g. passing Rect3 as a parameter
will corrupt the parameter after it, even if layout and size is exact as the C++ version. 
Rect3 has child structs (Vector3) which could be the reason. Be aware of other similar problems.

Mono cannot marshal structures? Taken from their documentation:
 Internal calls do not provide support for marshalling structures. This means that any API calls that take a structure 
 (excluding the system types like int32, int64, etc) must be passed as a pointer, in C# this means passing the value as a "ref" or "out" parameter.

----------------------------------------------------------------------
MenuItem

LATER: Add keyboard controls to GUIMenuBar (left/right arrows should move between entries if user is not browsing a sub-menu)
 - esc should cancel out of the menu bar
 - alt should focus the menu bar

----------------------------------------------------------------------
VisualStudio integration

VS integration will likely not work with VSExpress or Community edition
 - VSExpress doesn't support EnvDTE so the only option is to open it using a shell command which doesn't seem to offer precise parameters
 - Community edition should work similarily to Pro, but might have a different executable and/or registry paths

For later:
 - Make sure that 3rd party assemblies can be imported in the project, and that they are properly referenced in VS project generation and compilation

----------------------------------------------------------------------
Script compilation

For later:
 - I need to hook up script compilation with assembly refresh, and the build system.
   - e.g. when recompiling inside the editor it should automatically start compiling when changes are detected,
     show some kind of visual indicator and refresh assemblies when its done. When publishing it should recompile
	 assemblies for release. Also hook up console to compiler output?