--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

See GDrive/Resources doc for resources refactor

There seems to be some kind of memory corruption that happens when cloning game objects. During one clone the field entries provided to
ManagedSerializeArray::deserializeManagedInstance were reported as ManagedSerializedArray instead of ManagerSerializedFieldData types.
It's inconsistent to reproduce but started happening after I have modified managed object serialization to be on-demand. It's possibly
related to lambdas not capturing types as I expect them to. It always happens in the same place.

Properly implement getPropertyCopy and updateProperties that are called from RenderWindowManager.

Resource refresh:
 - Keep track of every single active ScriptObject
   - Before refresh serialize any managed component and managed resource
   - After refresh create new instances and restore mCachedPtr fields
   - After refresh restore managed component and managed resource serialized data
   - Pay special attention to C# types that store custom data which might not be serialized. I'll need to handle that manually or change where that data is stored.
   - Pay special attention to script objects that store references to MonoObject*, or MonoClass* (and similar) types (if they're not refreshed in initRuntimeData)
 - Check non-ScriptObject classes to ensure they properly refresh any references to: MonoClass, MonoField, MonoProperty, MonoMethod, MonoAssembly, function thunk
 - I should probably avoid calling constructor on restore since it may be doing some initialization. See how Unity does it.
   - Unity does call the constructor

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Multi-resource saving:
 - Modify Font so it doesn't contain a texture, but instead keeps a handle to it
 - Register it in its meta file
 - When saving such a resource with dependencies save the contained files to a sub-directory with the same name as top level resource
   - If it already exists in the manifest at a different location do it anyway, keep the other copy as-is in case user wanted it that way
   - I'm not sure whether to do this for all Resource::save calls or only ones originating from ProjectLIbrary?

Other:
Window resize end callback
Add cutoff plane when rendering discs for rotation handle.
What happens when I close widgets from C++ code (e.g. due to layout reload or change)? Will C# still try to access them?

C# SceneView:
Test new Scene window and fix every issue
Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

-----------------

Need a way to drag and drop items from Scene tree view to Scene view

AFTER I have scene widget in C#:
 - Implement free move handle and remaining handles
 - Test custom handles from C#
 - Test handle snapping

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK - Use the shader created in Unity

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add 2D move and scale
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------