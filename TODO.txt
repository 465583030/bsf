--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

Renderable TODO:

 - Restore RenderableElement (it was in RenderableProxy files)
 - I need to update Renderable with world transform
   - I've removed SceneObject dirty flags so that is no longer done anywhere
   - RenderableHandler should keep track of world transform
     - Also I should keep track of SceneObject active state to hide/show the object as needed
   - Make sure to call gSceneManager().updateRenderableTransforms(); BEFORE syncing
     and not like now when it's called in renderAll after sync

Disallow CoreObject creation from core thread
 - Add asserts in CoreObject::destroy and CoreObject::initialize
 - Possibly also add asserts to CoreThread::queueCommand and CoreThread::queueReturnCommand

Refactor RenderSystem and CoreThreadAccessor methods (move them to RenderSystem and make current RenderSystem a RenderSystemCore)

 New issues:
  - Since Mesh refactor when I select/deselect a gizmo the entire render texture flashes white for one frame (might be related to RT refactor instead)

HANDLE RESOURCE LOADING AND CORE OBJECT SYNC:
How to handle RenderableHandler (and other types) that reference resource handles? What if the handle is invalid and in the process 
of being loaded? The core thread needs to be notified when loading is complete so it retrieves the proper Core object.
 - Add getResourceDependencies() and markDependenciesDirty() to CoreObject
   - CoreObjectManager then keeps track of all resource handles and receives notifications from 
     Resources when a resource finishes loading or gets modified due to reimport
   - When such notification is issued CoreObjectManager performs a lookup among its resource handles to find 
     CoreObject (store CoreObject as a raw pointer or an ID, but make sure to handle deletion of CoreObject properly in either case)
   - That object then receives notifyResourceUpdated(const HResource& resource) which by default makes the object dirty
 - This can then be used for resource hot-swap functionality as well

BETTER SYNC IN GENERAL:
 - Extend CoreObject with getDependencies() that returns all child CoreObjects
 - Then when performing syncToCore I can iterate through all dependencies and sync them all
   - e.g. Material references GpuParams which reference GpuParamBlockBuffer, all of which require syncing
 - Add a method similar to syncToCore that just appends CoreSyncData to a larger object, so many objects
   can be synced at once.
 - Get rid of syncUpload/syncDownload methods and replace them with:
   - Custom sync in BansheeRenderer that iterates over all Renderable and Camera objects and syncs the dirty ones
     - Will likely want to remove core->sim sync with mesh bounds and other similar core->sync transfers
   - Custom sync for RenderTargets that happens both ways, likely handled by RenderableTargetManager

-----------------

Port SceneCameraController to C#
Port RenderTexture to C# and likely extend Texture2D so it accepts renderable flags. While at it add TextureCube and Texture3D as well.
 - Actually Texture2D doesn't seem to be implemented at all. Will also need to add PixelData wrapper.
 - Will I need to add support for readable textures? e.g. what happens when you try to read a texture from C#?
   - Almost certainly. It's very useful to be able to read textures.
   - I can't sync the threads when reading, it would be too slow. Have an AsyncOp similar to c++ code? 
   - Also DX11 already creates a temporary staging buffer when reading from a texture, so keeping yet another CPU
     copy seems like a waste.
Ensure that EditorWindow resize callback works properly.
 - Perhaps add OnResizeEnd callback that can be used for updating the render texture
Create a C# wrapper around ProjectSettings
Make a Script version of SceneEditorWindow
 - This would replace SceneEditorWidget so it would initialize scene grid and call
    update on handle manager and scene grid, as well as apply ProjectSettings to them.
 
Move handle is buggy as hell - It moves in wrong direction sometimes, sometimes it skips, other times collision seems to be wrong
Need a way to drag and drop items from Scene tree view to Scene view
When dragging a handle make sure it works when cursor leaves the scene view
Also make sure that handle manager receives mouse up event if its done outside of scene view

AFTER I have scene widget in C#:
 - Finish up C# Handles class so it returns proper values
 - Ensure fixed handle size and handle snapping works
 - Implement free move handle and remaining handles
 - Test custom handles from C#

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK
 - LIKELY USE PIXEL SceneGrid WITH AA
 - OR (better) instead of drawing rows and columns of lines, just draw a plane with procedural texture

---------------------------------------------------------------------
Render textures in C#:
 - In C# have Texture2D, TextureCube, TextureVolume. They should have a common Texture base.
   - Each of those can be created with a Renderable flag
 - Render textures mirror what we have in C++
   - RenderTexture and MultiRenderTexture (since we have these separate representation we don't need RenderBuffer that Unity has)
   - You can provide an existing texture from types listed above, or create a new render target and
      create a basic 2D texture (multiple constructors)
 - Both RT types should have their color buffer (s) and depth buffer accessible as a texture to be used for rendering, or for reading

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------