--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

----------------------------------------------------------------------
Assembly refresh

When serializing Camera I cannot save the reference to RenderTexture. Make it a Resource?
Possibly set up automatic refresh in debug mode after initialization? As an ad-hoc unit test

----------------------------------------------------------------------
Project library

Almost all of PRojectLibrary functionality is completely untested

Figure out how to create a C# BuiltinResources class. It should be able to load arbitrary resources from a non-project folder
 - I should move all the GUI element style creation out of code and make it just pure data (once I have an editor for it)
 - Will also need a debug button to reimport all the built-in resources

My GUID generation is screwed up. If multiple GUIDs are generated in succession then the timestamp will remain
the same and the only variable will be the 4byte random number, which can sometimes end up identical to the previous number.

----------------------------------------------------------------------
BuiltinResources
 - All data in ..\..\BuiltinData (if we start in /bin/Release/BansheeEd.exe)
 - Need BuiltinEngine and BuiltinEditor (separate classes) that internally do pretty much the same thing
   - Derive them from common base since most of the functionality will be reused
   - Make sure that commonly used resources are available directly and aren't required to call Load
 - Also have ..\..\RawBuiltinData where all the non-processed assets are
 - When compiled as debug, define Preprocess command which goes over all assets in ..\..\RawBuiltinData, imports them and outputs them to ..\..\BuiltinData
   - Preprocess can be done fully in C++

I need to make a GUISkin a resource so I can save it
 - It should be editable from the Editor (only when in debug mode) and not generated in code
 - Then in Preprocess it can just get copied from RawBuiltinData subfolder to the actual folder
 - Before I have editing capability it can just be generated in Preprocess step

Preprocess will also need to generate any Shaders or SpriteTextures
 - POSSIBLY wait until I get generate these assets directly in Editor, then just copy them over to Builtin
 - This way I can fully avoid writing any preprocess code

I still need to be able to access most of these assets from C++ (e.g. GUI element styles)
 - I need to add BuiltinResources.Load which should allow me to load all needed resources, from C++ or C#

----------------------------------------------------------------------
Resources
 - Load/Unload/UnloadUnused
 - Uses same paths as ProjectLibrary
 - It uses different logic depending on Application.isEditor
   - If not in editor then a different path is used
   - That path is ..\..\Data (relative to the executable)
   - When in editor it also does special ProjectLibrary check to ensure that resource is included in final project
 - Internally just calls Resources (C++) Load/Unload/UnloadUnused
 - Need a flag in ProjectLibrary to include a resource in the final build
   - Need to be able to set that flag from C# (Likely through ProjectLibrary) interface
 - The final build procedure for the game would then be:
   - Copy all the prebuilt binaries (Banshee libraries, Banshee assemblies, 3rd party libraries and prebuilt executable) from Editor install folder to output folder
    - Which set of binaries is used depends on selected platform (e.g. win/mac/linux or 32/64bit)
   - Recompile script assemblies if needed and copy them from project Internal folder to output folder
   - Copy the Builtin resources for engine from Editor install folder to output folder
   - Copy all the resources marked with the flag mentioned above to \Data subfolder in the output folder, preserving the same asset structure

----------------------------------------------------------------------
Simple stuff

C#:
Dialog.Show(title, text, btn1 text, btn1 callback, btn2 text, btn2 callback, btn3 text, btn3 callback)

Other simple stuff:
 - Inject an icon into an .exe (Win32 specific)
 - C# wrapper for GUISkin (and a way to assign the current skin to a window)
 - Move all the code files into subfolders so their hierarchy is similar to VS filters
 - Font doesn't have a C# interface
 - Material/Shader/Technique/Pass don't have a C# interface
 - Get rid of PoolAlloc and other unused allocators (plus fix bs_new and others which have weird overloads)
 - Call stack from C# to use in Debug.Log calls
 - Get rid of event callback from HString and figure out a better way
 - GUI TextureField similar to ResourceField but it displays the texture it has assigned
 - Getting rid of import on start would be a pretty big deal. Just adding a button in Editor "Reimport" should be good instead
 - Better handle and gizmo shaders

----------------------------------------------------------------------
Handles

When scaling using center make sure to offset the object before scale
Handles should probably not having shading, or have better shading.

Rotate handle:
 - How to handle local/global with rotate handle?
   - This maybe just determines initial rotation of the handle?
   - I don't think my code properly handles rotation handle transforms (e.g. arc drawing)

Ideally free scale handle indicator should always render and be interactable and never be hidden by axis scale indicators (Not high priority)

Later:
 - Raycast snapping Ribek suggested

----------------------------------------------------------------------
C# Material

C# material interface:
 - Pass
 - GpuProgram
 - DepthStencilState
 - RasterizerState
 - BlendState
 - SamplerState
 - Technique
 - Shader
 - Material

--------

Consider creating a shader effect language first?
 - It needs support for multiple gpu programs (vertex, fragment, etc)
 - Multiple passes, each with options to set up blend/rasterizer/depth-stencil states
 - Actual GpuProgram code can be marked with HLSL, HLSL11, GLSL (and later BSL) to compile for only specific API
 - Also needs to support techniques
 - Also render queue, priority, renderer semantics
 - Default parameter values?
 - Parameter ranges?

Then do I not need C# interface for anything but a Shader and Material. Shader doesn't need many (any?) properties and Material only needs property setters. Also potentially it also needs param block buffers and sampler states.

While I'm at this I might also consider dealing with includes and shader combinations

Questions:
 - How to deal with sampler states? Allow default ones in shader?
   - Yes, allow default ones. Plus allow sampler states to be tweaked from Material directly (without separate SamplerState class)
 - PRoblem where DX9 requires sampler to have the same name as texture, but DX11 has them separate. For now go with DX11 approach
   where you need to define the sampler separately, potentially allow "alias()" attribute so the system knows to look for other names.

Check D:\ExampleBFX.txt for an example effects file

Import:
 - A special importer for BFX files. It generates a HShader as its output. I MIGHT want to disable separate GpuProgram and state saving so
  I don't need to deal with multi-resources yet.

How to deal with includes?
 - You can do Include = "Path/to/CommonShader"
   - Path is relative to executable
 - CommonShader might not contain any techniques or passes, but instead just code.
  - It can use special Include & Code {} tags that allow it to specify various code
    for some language
 - How does the runtime resolve those shaders?
  - They are only resolved during import, after which just resource references are kept (i.e. its GUIDs)
  - The runtime should then be able to resolve the GUIDs easily

Use Bison to avoid the need to reference C# code from C++?

VALID KEYWORDS:
<<RasterizerState>>
Fill = Wire/Solid
Cull = None/CW/CCW
DepthBias = float
ScaledDepthBias = float
DepthClip = bool
Scissor = bool
Multisample = bool
AALine = bool

<<DepthStencilState>>
DepthRead = bool
DepthWrite = bool
CompareFunc = Fail/Pass/Less/LessEqual/Equal/NotEqual/GreaterEqual/Greater
Stencil = bool
StencilReadMask = byte
StencilWriteMask = byte
StencilOpFront = <StencilOp>
StencilOpBack = <StencilOp>

<<StencilOp>>
Fail = Keep/Zero/Replace/Increment/Decrement/IncrementWrap/DecrementWrap/Invert,
ZFail = Keep/Zero/Replace/Increment/Decrement/IncrementWrap/DecrementWrap/Invert,
Pass = Keep/Zero/Replace/Increment/Decrement/IncrementWrap/DecrementWrap/Invert,
CompFunc = Fail/Pass/Less/LessEqual/Equal/NotEqual/GreaterEqual/Greater

<<BlendState>>
AlphaToCoverage = bool
IndependantBlend = bool
PerTarget = <TargetBlendState>

<<TargetBlendState>>
Index = int (0 to 7)
Blend = bool
Color = <BlendDefinition>
Alpha = <BlendDefinition>
WriteMask = R/G/B/A/RG/RB/RA/GB/GA/BA/RGB/RGA/RBA/GBA/RGBA;

<<BlendDefinition>>
Source = One/Zero/DestColor/SrcColor/InvDestColor/InvSourceColor/DestAlpha/SrcAlpha/InvDestAlpha/InvSrcAlpha
Dest  = One/Zero/DestColor/SrcColor/InvDestColor/InvSourceColor/DestAlpha/SrcAlpha/InvDestAlpha/InvSrcAlpha
Op = Add/Subtract/RevereSubtract/Min/Max

<<SamplerState>>
AddressingMode =
{ u = Wrap/Mirror/Clamp/Border,
  v = Wrap/Mirror/Clamp/Border,
  w = Wrap/Mirror/Clamp/Border
}
MinFilter = None/Point/Linear/Anisotropic/PointComp/LinearComp/AnisotropicComp
MagFilter = None/Point/Linear/Anisotropic/PointComp/LinearComp/AnisotropicComp
MipFilter = None/Point/Linear/Anisotropic/PointComp/LinearComp/AnisotropicComp
MaxAniso = int
MipmapBias = float
MipMin = float
MipMax = float
BorderColor = <Color>
ComparisonFunc = Fail/Pass/Less/LessEqual/Equal/NotEqual/GreaterEqual/Greater

<<Color>>
R = float
G = float
B = float
A = float

Other types
float, int, bool, float2, float3, float4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4

FX types:
<<Shader>>
Separable = bool
Queue = int
Priority = int
Parameters = <ParamDef>
Blocks = <BlockDef>
Technique = <TechniqueDef>

<<ParamDef>>
Type name (: option)* (= block | literal);

<<BlockDef>>
Block name (: option)*;

<<TechniqueDef>>
Renderer = string (default strings recognized: "Any", "Default")
Language = string (default strings recognized: "HLSL9", "HLSL11", "GLSL", "HLSL"(11))
Include = string
Pass = <PassDef> 

<<PassDef>>
Rasterizer/DepthStencil/Blend state options as above
Vertex = code
Fragment = code
Geometry = code
Hull = code
Domain = code
Compute = code

Make sure to allow multiple properties of the same name (e.g. multiple Targets or Techniques). Where this isn't valid the program can ignore the extra ones.

<<<<<<<<AST>>>>>>>>>
Node

RootNode : OptionsNode
 - ParamsNode parameters
 - BlocksNode blocks

OptionsNode : Node
 - Dictionary<string, int> options;(identifier -> sym table index)
   - this can point to another node, float, int, bool, float2, etc.

ParamsNode : Node
 - ParamNode[] params

BlocksNode : Node
 - BlockNode[] blocks

ParamNode : Node
 - enum Type
 - string name
 - ParamQualifierNode[] qualifiers;
 - ValueType value (ValueType can be a SamplerState or any of the primitive types)

BlockNode : Node
 - string name
 - BlockQualifierNode[] qualififers;

ParamQualifierNode
 - ParamQualifierType type
 - T Value (create different qualifier node types for each qualifier since each has its own type (or multiple values)?)
  - But it's better just to have a void pointer and detect actual value stored here (it can be a struct with multiple values too)

BlockQualifierNode
 - BlockQualifierType type
 - T Value (create different qualifier node types for each qualifier since each has its own type (or multiple values)?)
  - But it's better just to have a void pointer and detect actual value stored here (it can be a struct with multiple values too)

-------------------

In lexer I use numbers to identify different values, but use enums instead so I can use the same ones when parsing AST

----------------------------------------------------------------------
Scene View

AFTER I have scene widget in C#:
 - Test custom handles from C#
 - Test handle snapping

Need a way to drag and drop items from Scene tree view to Scene view
 - When dragging a mesh it should by default create a SceneObject with a renderable
 - I might want a C# DragAndDrop class? It can contain Resource or SceneObject only for now, similar to Selection

----------------------------------------------------------------------
Other

Got a crash on shutdown that was caused by locking a mutex in an Event destructor. Event was Platform::onMouseCaptureChanged. 
Issue happened when I closed the app via the X button (if that's relevant). It doesn't seem to happen always.

Create a stack allocatable custom vector implementation and make getResourceDependencies and getCoreDependencies use it.
 - These methods are called often and cause allocations whenever they are.

Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

----------------------------------------------------------------------
Multi-resource saving
 - Modify Font so it doesn't contain a texture, but instead keeps a handle to it
 - Register it in its meta file
 - When saving such a resource with dependencies save the contained files to a sub-directory with the same name as top level resource
   - If it already exists in the manifest at a different location do it anyway, keep the other copy as-is in case user wanted it that way
   - I'm not sure whether to do this for all Resource::save calls or only ones originating from ProjectLIbrary?

/*********************************************************************/
/************************ LESS IMPORTANT *****************************/
/*********************************************************************/

----------------------------------------------------------------------
Mono notes

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Running embedded mono with VS attached causes managed null refs to be registered as access violations

There seems to be a bug in Mono when passing complex structs from C# to C++. e.g. passing Rect3 as a parameter
will corrupt the parameter after it, even if layout and size is exact as the C++ version. 
Rect3 has child structs (Vector3) which could be the reason. Be aware of other similar problems.

Mono cannot marshal structures? Taken from their documentation:
 Internal calls do not provide support for marshalling structures. This means that any API calls that take a structure 
 (excluding the system types like int32, int64, etc) must be passed as a pointer, in C# this means passing the value as a "ref" or "out" parameter.

----------------------------------------------------------------------
MenuItem

LATER: Add keyboard controls to GUIMenuBar (left/right arrows should move between entries if user is not browsing a sub-menu)
 - esc should cancel out of the menu bar
 - alt should focus the menu bar

----------------------------------------------------------------------
VisualStudio integration

VS integration will likely not work with VSExpress or Community edition
 - VSExpress doesn't support EnvDTE so the only option is to open it using a shell command which doesn't seem to offer precise parameters
 - Community edition should work similarily to Pro, but might have a different executable and/or registry paths

For later:
 - Make sure that 3rd party assemblies can be imported in the project, and that they are properly referenced in VS project generation and compilation

----------------------------------------------------------------------
Script compilation

For later:
 - I need to hook up script compilation with assembly refresh, and the build system.
   - e.g. when recompiling inside the editor it should automatically start compiling when changes are detected,
     show some kind of visual indicator and refresh assemblies when its done. When publishing it should recompile
	 assemblies for release. Also hook up console to compiler output?